# 결제 멀티스레딩
## 기존 결제 로직
1. 결제 전 총 결제 금액 (사전정보) db에 저장
2. 결제 수단 인증 ( 프런트엔드에서 진행 ) 이후 PG사에서 PID 발급
3. PID와 함께 결제 승인 API 호출 ( 속도가 매우 느림 )

기존에는 결제 서버가 나누어져 있지 않아 많은 유저가 동시에 결제 승인 API를 호출한다면,
오랜 기간동안 스레드를 점유하고 있게 된다. 이로 인해 스레드 풀 고갈이 발생해 성능에 심각한 영향을 미칠 수 있다.

## API 멀티스레딩 + 비동기 처리
1. APi 호출이 발생
2. kafka 이벤트 발행
3. worker 서버가 이벤트 받아 별도 스레드에서 비동기 처리
4. 외부 결제 승인 API 호출 및 로직 실행

## 백프레셔 전략
kafka기반의 이벤트 스트리밍 시스템에서 백프레셔 전략을 어떻게 취해야 하는가?
* 어떨 때 백프레셔 전략을 취해야 하는가?
* 어떻게 취해야 하는가?
* 어떤 전략을 취해야 하는가?

### 어떨 때?
이벤트 소비자보다 생산자가 더 많은 이벤트를 생산해 점점 이벤트가 쌓이는 상황을 처리하는 방법.

모든 스레드 풀이 사용중일 때가 바로 이 상황일 것이다.

### 어떻게?
* 컨슈머 측
  * 처리율 제어
  * 스레드 풀이 가득 찼을 때, 호출한 리스너 스레드가 작업을 처리하도록 하기
* 프로듀서 측
  * 발행 속도 조절

# 결론
결제 비동기 처리 하지 않기로 결정

결제 완료 이후 seat 상태 변경 -> lock 해제 진행
