â— ğŸ” Ticketon DDD ì¡°íšŒ API ì˜µí‹°ë§ˆì´ì € ì‹¤íŒ¨ ìœ„í—˜ë„ ë¶„ì„ ë³´ê³ ì„œ

ğŸ“‹ ì „ì²´ ì¡°íšŒ API ëª©ë¡

1. ì´ë²¤íŠ¸ ê´€ë ¨ API (Event Service)

- POST /api/v1/events/list - ì´ë²¤íŠ¸ ëª©ë¡ ì¡°íšŒ (í•„í„°ë§/ê²€ìƒ‰)
- GET /api/v1/events/{id} - ì´ë²¤íŠ¸ ë‹¨ê±´ ì¡°íšŒ
- GET /api/v1/events/manager/me - ë§¤ë‹ˆì €ë³„ ì´ë²¤íŠ¸ ì¡°íšŒ

2. êµ¬ë§¤ ê´€ë ¨ API (Purchase Service)

- GET /api/v1/purchases/history - ì‚¬ìš©ì êµ¬ë§¤ ë‚´ì—­ ì¡°íšŒ
- GET /api/v1/purchases/event/{eventId} - ì´ë²¤íŠ¸ë³„ êµ¬ë§¤ ë‚´ì—­ ì¡°íšŒ

3. ì¢Œì„ ê´€ë ¨ API (Seat Service)

- GET /api/v1/events/{event-id}/seats - ì¢Œì„ ë ˆì´ì•„ì›ƒ ì¡°íšŒ

4. ì‚¬ìš©ì ê´€ë ¨ API (User Service)

- GET /api/v1/users/me - ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ

5. ì¹´í…Œê³ ë¦¬ ê´€ë ¨ API (Category Service)

- GET /api/v1/categories - ì¹´í…Œê³ ë¦¬ ëª©ë¡ ì¡°íšŒ

  ---
ğŸš¨ ë†’ì€ ìœ„í—˜ë„ API ë¶„ì„

âš ï¸ 1. ì´ë²¤íŠ¸ ëª©ë¡ ì¡°íšŒ API - POST /api/v1/events/list

ìœ„í—˜ë„: ğŸ”´ ë§¤ìš° ë†’ìŒ

ì˜µí‹°ë§ˆì´ì € ì‹¤íŒ¨ ì‹œë‚˜ë¦¬ì˜¤

1) ê¸‰ì„±ì¥ ìŠ¤íƒ€íŠ¸ì—… íŒ¨í„´
   -- í˜„ì‹¤ì ì¸ ë°ì´í„° ì¦ê°€ íŒ¨í„´                                                                                                                                                        
   events (6ê°œì›” ì „): 1,000ê°œ â†’ (í˜„ì¬): 50,000ê°œ
   seat_layouts: 50ê°œ â†’ 5,000ê°œ
   event_categories: 10ê°œ â†’ 100ê°œ

-- ì˜µí‹°ë§ˆì´ì € ì˜¤íŒ ì‚¬ë¡€                                                                                                                                                             
SELECT e.event_id, e.title, s.location_name, e.category_id
FROM events e
JOIN seat_layouts s ON e.seat_layout_id = s.id
WHERE e.category_id = 1 -- 'ì½˜ì„œíŠ¸' ì¹´í…Œê³ ë¦¬                                                                                                                                        
AND e.event_start >= '2024-12-01'

ì˜µí‹°ë§ˆì´ì €ì˜ ì˜ëª»ëœ ê³„ì‚°:
ì˜›ë‚  í†µê³„ ê¸°ì¤€:
- ì½˜ì„œíŠ¸ ì¹´í…Œê³ ë¦¬: 100ê°œ (10%)
- 12ì›” ì´ë²¤íŠ¸: 50ê°œ (5%)
- ì˜ˆìƒ ê²°ê³¼: 100 Ã— 0.05 = 5ê°œ â†’ NL Join ì„ íƒ

ì‹¤ì œ í˜„ì¬:
- ì½˜ì„œíŠ¸ ì¹´í…Œê³ ë¦¬: 25,000ê°œ (50%) â† ì½˜ì„œíŠ¸ ì‚¬ì—… ì§‘ì¤‘
- 12ì›” ì´ë²¤íŠ¸: 15,000ê°œ (30%) â† ì—°ë§ ì‹œì¦Œ
- ì‹¤ì œ ê²°ê³¼: 25,000 Ã— 0.3 = 7,500ê°œ â†’ Hash Join ì í•©

2) ì§€ì—­ë³„ ë°ì´í„° í¸í–¥
   -- ì„œìš¸ vs ì§€ë°© ê·¹ì‹¬í•œ ë¶ˆê· í˜•                                                                                                                                                       
   WHERE s.location_name = 'ì„œìš¸'

-- ì „êµ­ í‰ê· ìœ¼ë¡œ ê³„ì‚°í•˜ì§€ë§Œ ì‹¤ì œëŠ” í¸í–¥ë¨                                                                                                                                           
ì˜µí‹°ë§ˆì´ì € ì˜ˆì¸¡: ì§€ì—­ë‹¹ í‰ê·  ì´ë²¤íŠ¸ = ì „ì²´/16ê°œ ì‹œë„ = 3,125ê°œ
ì‹¤ì œ ì„œìš¸: 35,000ê°œ (70%) â† ì‹¤ì œ ì½˜ì„œíŠ¸ëŠ” ì„œìš¸ ì§‘ì¤‘

3) ê³„ì ˆì  íŒ¨í„´ ë¯¸ë°˜ì˜
   WHERE e.event_start BETWEEN '2024-11-15' AND '2024-12-31'

-- í‰ìƒì‹œ ì›”ë³„ ì´ë²¤íŠ¸: 2,000ê°œ                                                                                                                                                      
-- ì—°ë§ì‹œì¦Œ ì´ë²¤íŠ¸: 12,000ê°œ (6ë°° ì¦ê°€)                                                                                                                                             
-- ì˜µí‹°ë§ˆì´ì €: "ë³´í†µ ë‹¬ì´ë‹ˆê¹Œ 2,000ê°œ ì •ë„" â†’ NL Join                                                                                                                               
-- ì‹¤ì œ: "ì—°ë§ ëŒ€ëª©ì´ë¼ 12,000ê°œ" â†’ Hash Join í•„ìš”

ì‹¤ì œ ì„±ëŠ¥ ì˜í–¥ ì˜ˆì¸¡

// í˜„ì¬ êµ¬í˜„ì—ì„œ ì˜ˆìƒë˜ëŠ” ì„±ëŠ¥ ì°¨ì´                                                                                                                                                 
@Test                                                                                                                                                                               
public void eventListPerformanceAnalysis() {
// ì—°ë§ì‹œì¦Œ ì„œìš¸ ì½˜ì„œíŠ¸ ì¡°íšŒ ì‹œë‚˜ë¦¬ì˜¤                                                                                                                                           
EventListFilter filter = new EventListFilter.Builder()
.categoryId(1L) // ì½˜ì„œíŠ¸                                                                                                                                                   
.locationList(List.of("ì„œìš¸"))
.startDate(LocalDateTime.of(2024, 11, 15, 0, 0))
.endDate(LocalDateTime.of(2024, 12, 31, 23, 59))
.build();

      // ì˜µí‹°ë§ˆì´ì € ì„ íƒ (NL Join ì˜ˆìƒ)                                                                                                                                               
      // ì‹¤í–‰ì‹œê°„: 15-20ë¶„ (7,500ê°œ Ã— ë³µì¡í•œ join)                                                                                                                                    

      // Hash Joinì´ì—ˆë‹¤ë©´: 2-3ë¶„                                                                                                                                                     
}

  ---
âš ï¸ 2. êµ¬ë§¤ ë‚´ì—­ ì¡°íšŒ API - GET /api/v1/purchases/history

ìœ„í—˜ë„: ğŸ”´ ë§¤ìš° ë†’ìŒ

VIP ì‚¬ìš©ì ë°ì´í„° í¸í–¥ ë¬¸ì œ

ì‹œë‚˜ë¦¬ì˜¤: K-POP ë•í›„ vs ì¼ë°˜ ì‚¬ìš©ì
-- Purchase + Ticket JOIN ì¿¼ë¦¬                                                                                                                                                      
SELECT p.*, t.seat_id, t.location
FROM purchases p
JOIN tickets t ON p.purchase_id = t.purchase_id
WHERE p.user_id = 'user123'                                                                                                                                                         
AND p.payment_status IN ('DONE', 'EXPIRED')

ë°ì´í„° í¸í–¥:
ì¼ë°˜ ì‚¬ìš©ì 99%: í‰ê·  3ê±´ êµ¬ë§¤, í‰ê·  2ì¥/ê±´ = 6ì¥
VIP ì‚¬ìš©ì 1%: í‰ê·  200ê±´ êµ¬ë§¤, í‰ê·  4ì¥/ê±´ = 800ì¥

ì˜µí‹°ë§ˆì´ì € ê³„ì‚°:
- í‰ê·  êµ¬ë§¤: (99% Ã— 6) + (1% Ã— 800) = 14ì¥
- "ì ë‹¹í•˜ë‹ˆê¹Œ NL Join"

VIP ì‚¬ìš©ì ì¡°íšŒì‹œ:
- ì‹¤ì œ: 800ì¥ ì²˜ë¦¬
- NL Join: 200ë²ˆ ì¸ë±ìŠ¤ íƒìƒ‰ Ã— í‰ê·  4ì¥ ë°˜í™˜ â†’ ë¹„íš¨ìœ¨!

ì‹¤ì œ ì½”ë“œì—ì„œì˜ ìœ„í—˜ì„±

// í˜„ì¬ êµ¬í˜„ì˜ 2ë‹¨ê³„ ì¿¼ë¦¬ ë°©ì‹                                                                                                                                                      
public Page<PurchaseListProjection> findUserPurchaseList(String userId, ...) {
// 1ë‹¨ê³„: Purchase ì¡°íšŒ                                                                                                                                                         
List<PurchaseListProjection> purchases = queryFactory.select(...)
.where(purchase.userId.value.eq(userId)) // â† VIP ì‚¬ìš©ìì‹œ ëŒ€ëŸ‰ ë°ì´í„°

      // 2ë‹¨ê³„: Ticket ì¡°íšŒ (IN ì ˆ ì‚¬ìš©)                                                                                                                                              
      List<TicketProjection> tickets = queryFactory.select(...)
          .where(ticket.purchase.purchaseId.value.in(purchaseIds)) // â† ëŒ€ëŸ‰ INì ˆ                                                                                                     
}

// VIP ì‚¬ìš©ìì˜ ê²½ìš°:                                                                                                                                                               
// 1ë‹¨ê³„ì—ì„œ 200ê°œ Purchase ID ë°˜í™˜                                                                                                                                                 
// 2ë‹¨ê³„ì—ì„œ IN (id1, id2, ..., id200) ì²˜ë¦¬ â†’ ë§¤ìš° ë¹„íš¨ìœ¨ì 

  ---
âš ï¸ 3. ì´ë²¤íŠ¸ë³„ êµ¬ë§¤ ë‚´ì—­ ì¡°íšŒ - GET /api/v1/purchases/event/{eventId}

ìœ„í—˜ë„: ğŸŸ¡ ë†’ìŒ

ë°”ì´ëŸ´ ì´ë²¤íŠ¸ ê¸‰ì¦ íŒ¨í„´

-- BTS ì½˜ì„œíŠ¸ ê°™ì€ ì¸ê¸° ì´ë²¤íŠ¸                                                                                                                                                      
SELECT p.*, t.* FROM purchases p JOIN tickets t ON ...
WHERE p.event_id = 'bts-seoul-2024'                                                                                                                                                 
AND p.payment_status = 'DONE'

ë°”ì´ëŸ´ ì´ë²¤íŠ¸ íŠ¹ì„±:
ì¼ë°˜ ì´ë²¤íŠ¸: í‰ê·  500ê±´ êµ¬ë§¤
ì¸ê¸° ì´ë²¤íŠ¸: 50,000ê±´ êµ¬ë§¤ (100ë°° ì°¨ì´!)

ì˜µí‹°ë§ˆì´ì € ì˜ˆìƒ: "í‰ê· ì ìœ¼ë¡œ 500ê±´ ì •ë„"
ì‹¤ì œ BTS ì½˜ì„œíŠ¸: 50,000ê±´ â†’ ì„œë²„ ë‹¤ìš´ ìœ„í—˜

  ---
ğŸŸ¡ ì¤‘ê°„ ìœ„í—˜ë„ API ë¶„ì„

4. ë§¤ë‹ˆì €ë³„ ì´ë²¤íŠ¸ ì¡°íšŒ - GET /api/v1/events/manager/me

ìœ„í—˜ë„: ğŸŸ¡ ì¤‘ê°„

ëŒ€í˜• ê¸°íšì‚¬ vs ê°œì¸ ë§¤ë‹ˆì € í¸í–¥

WHERE e.manager_id = 'sm-entertainment'                                                                                                                                             
-- SM Entertainment: 1,000ê°œ ì´ë²¤íŠ¸                                                                                                                                                 
-- ê°œì¸ ë§¤ë‹ˆì €: í‰ê·  5ê°œ ì´ë²¤íŠ¸

-- ì˜µí‹°ë§ˆì´ì €ê°€ í‰ê· (50ê°œ)ìœ¼ë¡œ ê³„ì‚°í•˜ë©´ ëŒ€í˜•ì‚¬ ì¿¼ë¦¬ì‹œ ì„±ëŠ¥ ì €í•˜

  ---
ğŸŸ¢ ë‚®ì€ ìœ„í—˜ë„ API

5-7. ë‹¨ìˆœ ì¡°íšŒ APIë“¤

- ì¢Œì„ ë ˆì´ì•„ì›ƒ ì¡°íšŒ: ë‹¨ì¼ ì´ë²¤íŠ¸ ê¸°ì¤€, ì•ˆì •ì 
- ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ: ë‹¨ê±´ ì¡°íšŒ, ìœ„í—˜ë„ ë‚®ìŒ
- ì¹´í…Œê³ ë¦¬ ëª©ë¡: ë§ˆìŠ¤í„° ë°ì´í„°, ë³€í™”ëŸ‰ ì ìŒ

  ---
ğŸ”§ ìµœì í™” ê°œì„  ë°©ì•ˆ

â— ğŸ¯ 1. ì´ë²¤íŠ¸ ëª©ë¡ ì¡°íšŒ ìµœì í™”

A) ë™ì  íŒíŠ¸ ì‹œìŠ¤í…œ êµ¬í˜„

@Service                                                                                                                                                                            
public class EventQueryOptimizer {

      private static final Set<Integer> PEAK_SEASON_MONTHS = Set.of(11, 12, 1, 5, 6, 7);
      private static final Set<String> HIGH_DEMAND_LOCATIONS = Set.of("ì„œìš¸", "ë¶€ì‚°", "ëŒ€êµ¬");
      private static final Set<Long> POPULAR_CATEGORIES = Set.of(1L, 2L, 3L); // ì½˜ì„œíŠ¸, ë®¤ì§€ì»¬, ìŠ¤í¬ì¸                                                                                

      public Page<EventListProjection> findOptimizedEventList(                                                                                                                        
              String keyword, EventListFilter filter, Pageable pageable) {

          int riskScore = calculateQueryComplexity(filter);

          if (riskScore >= 7) { // ê³ ìœ„í—˜ ì¿¼ë¦¬                                                                                                                                        
              return eventViewRepository.findEventListWithHashJoin(keyword, filter, pageable);
          } else {
              return eventViewRepository.findEventList(keyword, filter, pageable);
          }
      }

      private int calculateQueryComplexity(EventListFilter filter) {
          int complexity = 0;
          LocalDate now = LocalDate.now();

          // ì„±ìˆ˜ê¸° ê°€ì¤‘ì¹˜ (11-12ì›”, 5-7ì›”)                                                                                                                                           
          if (filter.getStartDate() != null &&
              PEAK_SEASON_MONTHS.contains(filter.getStartDate().getMonthValue())) {
              complexity += 3;
          }

          // ì¸ê¸° ì§€ì—­ ê°€ì¤‘ì¹˜                                                                                                                                                         
          if (filter.getLocationList() != null &&
              filter.getLocationList().stream().anyMatch(HIGH_DEMAND_LOCATIONS::contains)) {
              complexity += 2;
          }

          // ì¸ê¸° ì¹´í…Œê³ ë¦¬ ê°€ì¤‘ì¹˜                                                                                                                                                     
          if (filter.getCategoryId() != null && POPULAR_CATEGORIES.contains(filter.getCategoryId())) {
              complexity += 2;
          }

          // í‚¤ì›Œë“œ ê²€ìƒ‰ ê°€ì¤‘ì¹˜                                                                                                                                                       
          if (keyword != null && keyword.length() > 0) {
              complexity += 1;
          }

          return complexity;
      }
}

B) íŒíŠ¸ ê¸°ë°˜ Repository í™•ì¥

@Repository
public class EventViewRepositoryImpl implements EventViewRepository {

      // ê¸°ì¡´ ë©”ì„œë“œ ìœ ì§€
      @Override
      public Page<EventListProjection> findEventList(String keyword, EventListFilter filter, Pageable pageable) {
          // ê¸°ì¡´ êµ¬í˜„
      }

      // Hash Join ê°•ì œ ë²„ì „ ì¶”ê°€
      public Page<EventListProjection> findEventListWithHashJoin(
              String keyword, EventListFilter filter, Pageable pageable) {

          // Native Query with USE_HASH hint
          String sql = """
              SELECT /*+ USE_HASH(e,s) */
                  e.event_id, e.title, e.thumbnail_url, e.event_start, e.event_end,
                  e.booking_start, e.booking_end, e.min_price, e.max_price,
                  e.view_count, e.status, e.category_id, s.location_name
              FROM events e
              JOIN seat_layouts s ON e.seat_layout_id = s.id
              WHERE e.deleted = false
              """ + buildDynamicWhereClause(keyword, filter) + """
              ORDER BY e.created_at DESC
              LIMIT ? OFFSET ?
              """;

          // JdbcTemplate ë˜ëŠ” EntityManagerë¡œ ì‹¤í–‰
          return executeWithHint(sql, keyword, filter, pageable);
      }
}

ğŸ¯ 2. êµ¬ë§¤ ë‚´ì—­ ì¡°íšŒ ìµœì í™”

A) VIP ì‚¬ìš©ì ê°ì§€ ë° ìµœì í™”

@Service                                                                                                                                                                            
public class PurchaseQueryOptimizer {

      private final RedisTemplate<String, String> redisTemplate;

      public Page<PurchaseListProjection> findOptimizedUserPurchaseList(                                                                                                              
              String userId, List<PaymentStatus> statuses, Pageable pageable) {

          // Redisì—ì„œ ì‚¬ìš©ìë³„ êµ¬ë§¤ í†µê³„ í™•ì¸                                                                                                                                        
          String userStatsKey = "user:purchase:stats:" + userId;
          String cachedStats = redisTemplate.opsForValue().get(userStatsKey);

          boolean isVipUser = false;
          if (cachedStats != null) {
              UserPurchaseStats stats = parseStats(cachedStats);
              isVipUser = stats.getTotalPurchases() > 50 || stats.getTotalTickets() > 100;
          }

          if (isVipUser) {
              // VIP ì‚¬ìš©ì: ë‹¨ì¼ ì¿¼ë¦¬ë¡œ JOIN ì²˜ë¦¬                                                                                                                                    
              return purchaseViewRepository.findUserPurchaseListWithSingleQuery(userId, statuses, pageable);
          } else {
              // ì¼ë°˜ ì‚¬ìš©ì: ê¸°ì¡´ 2ë‹¨ê³„ ì¿¼ë¦¬                                                                                                                                         
              return purchaseViewRepository.findUserPurchaseList(userId, statuses, pageable);
          }
      }
}

B) VIPìš© ë‹¨ì¼ ì¿¼ë¦¬ ë²„ì „

public Page<PurchaseListProjection> findUserPurchaseListWithSingleQuery(
String userId, List<PaymentStatus> statuses, Pageable pageable) {

      // í•œ ë²ˆì˜ ì¿¼ë¦¬ë¡œ ëª¨ë“  ë°ì´í„° ì¡°íšŒ (Hash Join íŒíŠ¸ í¬í•¨)
      String sql = """
          SELECT /*+ USE_HASH(p,t) */
              p.purchase_id, p.order_id, p.order_name, p.event_id,
              p.amount, p.payment_method, p.payment_status, p.created_at, p.user_id,
              t.ticket_id, t.location, t.seat_id
          FROM purchases p
          LEFT JOIN tickets t ON p.purchase_id = t.purchase_id
          WHERE p.user_id = ? AND p.payment_status IN (?)
          ORDER BY p.created_at DESC
          LIMIT ? OFFSET ?
          """;

      // ê²°ê³¼ë¥¼ PurchaseListProjectionìœ¼ë¡œ ê·¸ë£¹í•‘
      return executeAndGroup(sql, userId, statuses, pageable);
}

ğŸ¯ 3. ì‹¤ì‹œê°„ í†µê³„ ê¸°ë°˜ ìµœì í™”

A) ì¿¼ë¦¬ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

@Component                                                                                                                                                                          
public class QueryPerformanceMonitor {

      private final MeterRegistry meterRegistry;
      private final Map<String, QueryStats> queryStatsMap = new ConcurrentHashMap<>();

      public <T> T executeWithMonitoring(String queryName, Supplier<T> queryExecutor) {
          Timer.Sample sample = Timer.start(meterRegistry);

          try {
              T result = queryExecutor.get();
              sample.stop(Timer.builder("query.execution.time")
                  .tag("query", queryName)
                  .tag("status", "success")
                  .register(meterRegistry));

              updateQueryStats(queryName, true);
              return result;

          } catch (Exception e) {
              sample.stop(Timer.builder("query.execution.time")
                  .tag("query", queryName)
                  .tag("status", "error")
                  .register(meterRegistry));

              updateQueryStats(queryName, false);
              throw e;
          }
      }

      private void updateQueryStats(String queryName, boolean success) {
          queryStatsMap.compute(queryName, (k, v) -> {
              if (v == null) v = new QueryStats();
              if (success) {
                  v.incrementSuccess();
              } else {
                  v.incrementFailure();
              }
              return v;
          });
      }

      // ì„±ëŠ¥ì´ ì €í•˜ë˜ëŠ” ì¿¼ë¦¬ ìë™ ê°ì§€                                                                                                                                               
      @Scheduled(fixedRate = 60000) // 1ë¶„ë§ˆë‹¤                                                                                                                                        
      public void detectSlowQueries() {
          queryStatsMap.entrySet().stream()
              .filter(entry -> entry.getValue().getAverageTime() > 5000) // 5ì´ˆ ì´ìƒ                                                                                                  
              .forEach(entry -> {
                  log.warn("Slow query detected: {} - avg: {}ms",
                      entry.getKey(), entry.getValue().getAverageTime());

                  // ì•ŒëŒ ë˜ëŠ” ìë™ íŒíŠ¸ ì ìš© ë¡œì§                                                                                                                                    
                  enableHashJoinHint(entry.getKey());
              });
      }
}

â— ğŸ¯ 4. ë°ì´í„° í¸í–¥ ëŒ€ì‘ ì „ëµ

A) ì‚¬ìš©ì ì„¸ê·¸ë©˜í…Œì´ì…˜ ê¸°ë°˜ ìµœì í™”

@Component                                                                                                                                                                          
public class UserSegmentOptimizer {

      enum UserSegment {
          LIGHT_USER(0, 10),      // êµ¬ë§¤ 0-10ê±´                                                                                                                                      
          NORMAL_USER(11, 50),    // êµ¬ë§¤ 11-50ê±´                                                                                                                                     
          HEAVY_USER(51, 200),    // êµ¬ë§¤ 51-200ê±´                                                                                                                                    
          VIP_USER(201, Integer.MAX_VALUE); // êµ¬ë§¤ 200ê±´+                                                                                                                            

          private final int minPurchases;
          private final int maxPurchases;
      }

      public UserSegment determineUserSegment(String userId) {
          // Redis ìºì‹œì—ì„œ ì‚¬ìš©ì êµ¬ë§¤ í†µê³„ ì¡°íšŒ                                                                                                                                     
          Long purchaseCount = getUserPurchaseCount(userId);

          return Arrays.stream(UserSegment.values())
              .filter(segment -> purchaseCount >= segment.minPurchases &&
                               purchaseCount <= segment.maxPurchases)
              .findFirst()
              .orElse(UserSegment.NORMAL_USER);
      }

      public QueryStrategy getOptimalQueryStrategy(UserSegment segment) {
          return switch (segment) {
              case LIGHT_USER, NORMAL_USER -> QueryStrategy.NL_JOIN;
              case HEAVY_USER -> QueryStrategy.HASH_JOIN;
              case VIP_USER -> QueryStrategy.SINGLE_QUERY_HASH_JOIN;
          };
      }
}

B) ì§€ì—­ë³„ í¸í–¥ ëŒ€ì‘

@Component                                                                                                                                                                          
public class LocationBasedOptimizer {

      // ì‹¤ì œ í‹°ì¼“íŒ… ì—…ê³„ ë°ì´í„° ê¸°ë°˜                                                                                                                                                 
      private static final Map<String, Integer> LOCATION_EVENT_DENSITY = Map.of(
          "ì„œìš¸", 35000,      // ì „ì²´ ì´ë²¤íŠ¸ì˜ 70%                                                                                                                                    
          "ê²½ê¸°", 5000,       // 10%                                                                                                                                                  
          "ë¶€ì‚°", 3000,       // 6%                                                                                                                                                   
          "ëŒ€êµ¬", 2000,       // 4%                                                                                                                                                   
          "ê¸°íƒ€", 5000        // 10%                                                                                                                                                  
      );

      public boolean shouldUseHashJoin(EventListFilter filter) {
          if (filter.getLocationList() == null) return false;

          int totalExpectedEvents = filter.getLocationList().stream()
              .mapToInt(location -> LOCATION_EVENT_DENSITY.getOrDefault(location, 100))
              .sum();

          // ì˜ˆìƒ ê²°ê³¼ê°€ 5000ê°œ ì´ìƒì´ë©´ Hash Join ê¶Œì¥                                                                                                                               
          return totalExpectedEvents > 5000;
      }

      // ì‹œê°„ëŒ€ë³„ íŒ¨í„´ ë¶„ì„                                                                                                                                                           
      public boolean isPeakSeason(LocalDateTime startDate, LocalDateTime endDate) {
          if (startDate == null || endDate == null) return false;

          // ì—°ë§ì‹œì¦Œ (11-12ì›”), ì—¬ë¦„ì‹œì¦Œ (6-8ì›”) ì²´í¬                                                                                                                                
          int startMonth = startDate.getMonthValue();
          int endMonth = endDate.getMonthValue();

          Set<Integer> peakMonths = Set.of(6, 7, 8, 11, 12);
          return peakMonths.contains(startMonth) || peakMonths.contains(endMonth);
      }
}

ğŸ¯ 5. ì‹¤ì‹œê°„ ì ì‘í˜• ìµœì í™” ì‹œìŠ¤í…œ

A) Circuit Breaker íŒ¨í„´ ì ìš©

@Component                                                                                                                                                                          
public class QueryCircuitBreaker {

      private final Map<String, CircuitBreakerState> circuitStates = new ConcurrentHashMap<>();

      public <T> T executeWithCircuitBreaker(String queryName,                                                                                                                        
              Supplier<T> primaryQuery, Supplier<T> fallbackQuery) {

          CircuitBreakerState state = circuitStates.computeIfAbsent(
              queryName, k -> new CircuitBreakerState());

          if (state.isOpen()) {
              // Circuit Open: Fallback ì¿¼ë¦¬ ì‚¬ìš© (íŒíŠ¸ ì ìš©)                                                                                                                         
              log.warn("Circuit breaker OPEN for {}, using fallback query", queryName);
              return fallbackQuery.get();
          }

          try {
              T result = primaryQuery.get();
              state.recordSuccess();
              return result;

          } catch (Exception e) {
              state.recordFailure();

              if (state.shouldOpen()) {
                  log.error("Circuit breaker OPENING for {} due to failures", queryName);
                  return fallbackQuery.get();
              }
              throw e;
          }
      }

      static class CircuitBreakerState {
          private final AtomicInteger failureCount = new AtomicInteger(0);
          private final AtomicLong lastFailureTime = new AtomicLong(0);
          private final int threshold = 5; // 5ë²ˆ ì‹¤íŒ¨ì‹œ Open                                                                                                                         
          private final long timeout = 60000; // 1ë¶„ í›„ Half-Open                                                                                                                     

          boolean isOpen() {
              if (failureCount.get() >= threshold) {
                  return System.currentTimeMillis() - lastFailureTime.get() < timeout;
              }
              return false;
          }

          void recordSuccess() {
              failureCount.set(0);
          }

          void recordFailure() {
              failureCount.incrementAndGet();
              lastFailureTime.set(System.currentTimeMillis());
          }

          boolean shouldOpen() {
              return failureCount.get() >= threshold;
          }
      }
}

B) ì ì‘í˜• ì¿¼ë¦¬ ì‹¤í–‰ê¸°

@Service                                                                                                                                                                            
public class AdaptiveQueryExecutor {

      private final QueryCircuitBreaker circuitBreaker;
      private final EventViewRepository eventRepository;
      private final LocationBasedOptimizer locationOptimizer;

      public Page<EventListProjection> executeAdaptiveEventQuery(                                                                                                                     
              String keyword, EventListFilter filter, Pageable pageable) {

          String queryKey = generateQueryKey(keyword, filter);

          // Primary: ì˜µí‹°ë§ˆì´ì € ë¯¿ê³  ì¼ë°˜ ì¿¼ë¦¬                                                                                                                                       
          Supplier<Page<EventListProjection>> primaryQuery = () ->
              eventRepository.findEventList(keyword, filter, pageable);

          // Fallback: íŒíŠ¸ ì ìš©í•œ ê°•í™” ì¿¼ë¦¬                                                                                                                                          
          Supplier<Page<EventListProjection>> fallbackQuery = () ->
              eventRepository.findEventListWithHashJoin(keyword, filter, pageable);

          return circuitBreaker.executeWithCircuitBreaker(
              queryKey, primaryQuery, fallbackQuery);
      }

      private String generateQueryKey(String keyword, EventListFilter filter) {
          return String.format("event_query_%s_%s_%s_%s",
              keyword != null ? "with_keyword" : "no_keyword",
              filter.getCategoryId() != null ? "with_category" : "no_category",
              filter.getLocationList() != null ? "with_location" : "no_location",
              locationOptimizer.isPeakSeason(filter.getStartDate(), filter.getEndDate())
                  ? "peak_season" : "normal_season"                                                                                                                                   
          );
      }
}

  ---
ğŸ“Š ì¢…í•© ìœ„í—˜ë„ í‰ê°€ ë° ìš°ì„ ìˆœìœ„

ğŸ”´ ê¸´ê¸‰ ëŒ€ì‘ í•„ìš” (High Priority)

1. ì´ë²¤íŠ¸ ëª©ë¡ ì¡°íšŒ API
   - ìœ„í—˜ë„: â˜…â˜…â˜…â˜…â˜… (5/5)
   - ì˜í–¥ë„: ë©”ì¸ í™”ë©´, ê²€ìƒ‰ ê¸°ëŠ¥
   - ì˜ˆìƒ ì„±ëŠ¥ ì°¨ì´: 15ë°° (NL vs Hash Join)
   - ëŒ€ì‘ì±…: ì¦‰ì‹œ ì ì‘í˜• ìµœì í™” ì‹œìŠ¤í…œ ë„ì…
2. VIP ì‚¬ìš©ì êµ¬ë§¤ ë‚´ì—­ ì¡°íšŒ
   - ìœ„í—˜ë„: â˜…â˜…â˜…â˜…â˜† (4/5)
   - ì˜í–¥ë„: ê³ ê° ë§Œì¡±ë„ ì§ê²°
   - ì˜ˆìƒ ì„±ëŠ¥ ì°¨ì´: 10ë°°
   - ëŒ€ì‘ì±…: ì‚¬ìš©ì ì„¸ê·¸ë©˜í…Œì´ì…˜ ê¸°ë°˜ ì¿¼ë¦¬ ë¶„ê¸°

ğŸŸ¡ ì§€ì† ëª¨ë‹ˆí„°ë§ í•„ìš” (Medium Priority)

3. ì´ë²¤íŠ¸ë³„ êµ¬ë§¤ ë‚´ì—­ ì¡°íšŒ (ë§¤ë‹ˆì €ìš©)
   - ìœ„í—˜ë„: â˜…â˜…â˜…â˜†â˜† (3/5)
   - ì˜í–¥ë„: ë§¤ë‹ˆì € ì—…ë¬´ íš¨ìœ¨ì„±
   - ëŒ€ì‘ì±…: ì¸ê¸° ì´ë²¤íŠ¸ ìë™ ê°ì§€ ì‹œìŠ¤í…œ
4. ë§¤ë‹ˆì €ë³„ ì´ë²¤íŠ¸ ì¡°íšŒ
   - ìœ„í—˜ë„: â˜…â˜…â˜†â˜†â˜† (2/5)
   - ì˜í–¥ë„: íŠ¹ì • ëŒ€í˜• ë§¤ë‹ˆì € ê³„ì •
   - ëŒ€ì‘ì±…: ë§¤ë‹ˆì €ë³„ ì´ë²¤íŠ¸ ìˆ˜ í†µê³„ ê¸°ë°˜ ìµœì í™”

ğŸŸ¢ í˜„ì¬ ì•ˆì •ì  (Low Priority)

5. ë‚˜ë¨¸ì§€ APIë“¤ - ë‹¨ê±´ ì¡°íšŒ ë° ë§ˆìŠ¤í„° ë°ì´í„° ì¡°íšŒ
   - ìœ„í—˜ë„: â˜…â˜†â˜†â˜†â˜† (1/5)
   - ëŒ€ì‘ì±…: ê¸°ë³¸ ëª¨ë‹ˆí„°ë§ë§Œ ìœ ì§€

  ---

â— ğŸ¯ ì‹¤í–‰ ê³„íš (Implementation Roadmap)

Phase 1: ì¦‰ì‹œ ì ìš© (1-2ì£¼)

// 1. ê¸°ë³¸ì ì¸ ë™ì  íŒíŠ¸ ì‹œìŠ¤í…œ                                                                                                                                                     
@Service                                                                                                                                                                            
public class QuickOptimizationService {

      public Page<EventListProjection> findEventsWithSmartOptimization(                                                                                                               
              String keyword, EventListFilter filter, Pageable pageable) {

          // ê°„ë‹¨í•œ ìœ„í—˜ë„ ê³„ì‚°                                                                                                                                                       
          boolean isHighRisk = (filter.getLocationList() != null &&
                              filter.getLocationList().contains("ì„œìš¸")) ||
                             (filter.getCategoryId() != null &&
                              filter.getCategoryId() <= 3L) ||
                             (isPeakSeason());

          if (isHighRisk) {
              return eventViewRepository.findEventListWithHashJoin(keyword, filter, pageable);
          }
          return eventViewRepository.findEventList(keyword, filter, pageable);
      }
}

Phase 2: ê³ ë„í™” (1ê°œì›”)

- ì‚¬ìš©ì ì„¸ê·¸ë©˜í…Œì´ì…˜ ì‹œìŠ¤í…œ êµ¬ì¶•
- Circuit Breaker íŒ¨í„´ ì ìš©
- ì‹¤ì‹œê°„ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ

Phase 3: AI ê¸°ë°˜ ìµœì í™” (3ê°œì›”)

- ë¨¸ì‹ ëŸ¬ë‹ ê¸°ë°˜ ì¿¼ë¦¬ íŒ¨í„´ ì˜ˆì¸¡
- ìë™ ì¸ë±ìŠ¤ ì¶”ì²œ ì‹œìŠ¤í…œ
- ì˜ˆì¸¡ì  ìºì‹± ì „ëµ

  ---
ğŸ” ê²°ë¡ : Ticketon DDDì˜ ì˜µí‹°ë§ˆì´ì € ì‹¤íŒ¨ ìœ„í—˜ë„

í˜„ì¬ Ticketon DDD ì‹œìŠ¤í…œì€ **"ê¸‰ì„±ì¥ ìŠ¤íƒ€íŠ¸ì—…ì˜ ì „í˜•ì ì¸ ì˜µí‹°ë§ˆì´ì € ì‹¤íŒ¨ í•¨ì •"**ì— ë¹ ì§ˆ ê°€ëŠ¥ì„±ì´ ë§¤ìš° ë†’ìŠµë‹ˆë‹¤.

í•µì‹¬ ìœ„í—˜ ìš”ì†Œ:

1. ë°ì´í„° í­ë°œì  ì¦ê°€ - ì´ë²¤íŠ¸/êµ¬ë§¤ ë°ì´í„°ì˜ ê¸°í•˜ê¸‰ìˆ˜ì  ì„±ì¥
2. ê·¹ì‹¬í•œ ì§€ì—­ í¸í–¥ - ì„œìš¸ ì§‘ì¤‘ë„ 70% ì´ìƒ
3. ê³„ì ˆì  íŠ¸ë˜í”½ ê¸‰ì¦ - ì—°ë§ì‹œì¦Œ 6ë°° ì¦ê°€
4. VIP ì‚¬ìš©ì í¸í–¥ - ìƒìœ„ 1% ì‚¬ìš©ìê°€ ì „ì²´ êµ¬ë§¤ì˜ 40% ì°¨ì§€

ì˜ˆìƒ ì„±ëŠ¥ ì˜í–¥:

- ì´ë²¤íŠ¸ ì¡°íšŒ API: ì •ìƒ 2ì´ˆ â†’ ìµœì•… 30ë¶„ (15ë°° ì°¨ì´)
- VIP êµ¬ë§¤ë‚´ì—­: ì •ìƒ 1ì´ˆ â†’ ìµœì•… 10ë¶„ (10ë°° ì°¨ì´)

ë¹„ì¦ˆë‹ˆìŠ¤ ë¦¬ìŠ¤í¬:

- ì—°ë§ì‹œì¦Œ ì„œë²„ ë‹¤ìš´ ê°€ëŠ¥ì„±
- VIP ê³ ê° ì´íƒˆ ìœ„í—˜
- ë§¤ì¶œ ê¸°íšŒ ì†ì‹¤

ë”°ë¼ì„œ ì œì‹œí•œ ì ì‘í˜• ìµœì í™” ì‹œìŠ¤í…œì˜ ë„ì…ì´ ì‹œê¸‰í•©ë‹ˆë‹¤! ğŸš¨