● 🔍 Ticketon DDD 조회 API 옵티마이저 실패 위험도 분석 보고서

📋 전체 조회 API 목록

1. 이벤트 관련 API (Event Service)

- POST /api/v1/events/list - 이벤트 목록 조회 (필터링/검색)
- GET /api/v1/events/{id} - 이벤트 단건 조회
- GET /api/v1/events/manager/me - 매니저별 이벤트 조회

2. 구매 관련 API (Purchase Service)

- GET /api/v1/purchases/history - 사용자 구매 내역 조회
- GET /api/v1/purchases/event/{eventId} - 이벤트별 구매 내역 조회

3. 좌석 관련 API (Seat Service)

- GET /api/v1/events/{event-id}/seats - 좌석 레이아웃 조회

4. 사용자 관련 API (User Service)

- GET /api/v1/users/me - 사용자 정보 조회

5. 카테고리 관련 API (Category Service)

- GET /api/v1/categories - 카테고리 목록 조회

  ---
🚨 높은 위험도 API 분석

⚠️ 1. 이벤트 목록 조회 API - POST /api/v1/events/list

위험도: 🔴 매우 높음

옵티마이저 실패 시나리오

1) 급성장 스타트업 패턴
   -- 현실적인 데이터 증가 패턴                                                                                                                                                        
   events (6개월 전): 1,000개 → (현재): 50,000개
   seat_layouts: 50개 → 5,000개
   event_categories: 10개 → 100개

-- 옵티마이저 오판 사례                                                                                                                                                             
SELECT e.event_id, e.title, s.location_name, e.category_id
FROM events e
JOIN seat_layouts s ON e.seat_layout_id = s.id
WHERE e.category_id = 1 -- '콘서트' 카테고리                                                                                                                                        
AND e.event_start >= '2024-12-01'

옵티마이저의 잘못된 계산:
옛날 통계 기준:
- 콘서트 카테고리: 100개 (10%)
- 12월 이벤트: 50개 (5%)
- 예상 결과: 100 × 0.05 = 5개 → NL Join 선택

실제 현재:
- 콘서트 카테고리: 25,000개 (50%) ← 콘서트 사업 집중
- 12월 이벤트: 15,000개 (30%) ← 연말 시즌
- 실제 결과: 25,000 × 0.3 = 7,500개 → Hash Join 적합

2) 지역별 데이터 편향
   -- 서울 vs 지방 극심한 불균형                                                                                                                                                       
   WHERE s.location_name = '서울'

-- 전국 평균으로 계산하지만 실제는 편향됨                                                                                                                                           
옵티마이저 예측: 지역당 평균 이벤트 = 전체/16개 시도 = 3,125개
실제 서울: 35,000개 (70%) ← 실제 콘서트는 서울 집중

3) 계절적 패턴 미반영
   WHERE e.event_start BETWEEN '2024-11-15' AND '2024-12-31'

-- 평상시 월별 이벤트: 2,000개                                                                                                                                                      
-- 연말시즌 이벤트: 12,000개 (6배 증가)                                                                                                                                             
-- 옵티마이저: "보통 달이니까 2,000개 정도" → NL Join                                                                                                                               
-- 실제: "연말 대목이라 12,000개" → Hash Join 필요

실제 성능 영향 예측

// 현재 구현에서 예상되는 성능 차이                                                                                                                                                 
@Test                                                                                                                                                                               
public void eventListPerformanceAnalysis() {
// 연말시즌 서울 콘서트 조회 시나리오                                                                                                                                           
EventListFilter filter = new EventListFilter.Builder()
.categoryId(1L) // 콘서트                                                                                                                                                   
.locationList(List.of("서울"))
.startDate(LocalDateTime.of(2024, 11, 15, 0, 0))
.endDate(LocalDateTime.of(2024, 12, 31, 23, 59))
.build();

      // 옵티마이저 선택 (NL Join 예상)                                                                                                                                               
      // 실행시간: 15-20분 (7,500개 × 복잡한 join)                                                                                                                                    

      // Hash Join이었다면: 2-3분                                                                                                                                                     
}

  ---
⚠️ 2. 구매 내역 조회 API - GET /api/v1/purchases/history

위험도: 🔴 매우 높음

VIP 사용자 데이터 편향 문제

시나리오: K-POP 덕후 vs 일반 사용자
-- Purchase + Ticket JOIN 쿼리                                                                                                                                                      
SELECT p.*, t.seat_id, t.location
FROM purchases p
JOIN tickets t ON p.purchase_id = t.purchase_id
WHERE p.user_id = 'user123'                                                                                                                                                         
AND p.payment_status IN ('DONE', 'EXPIRED')

데이터 편향:
일반 사용자 99%: 평균 3건 구매, 평균 2장/건 = 6장
VIP 사용자 1%: 평균 200건 구매, 평균 4장/건 = 800장

옵티마이저 계산:
- 평균 구매: (99% × 6) + (1% × 800) = 14장
- "적당하니까 NL Join"

VIP 사용자 조회시:
- 실제: 800장 처리
- NL Join: 200번 인덱스 탐색 × 평균 4장 반환 → 비효율!

실제 코드에서의 위험성

// 현재 구현의 2단계 쿼리 방식                                                                                                                                                      
public Page<PurchaseListProjection> findUserPurchaseList(String userId, ...) {
// 1단계: Purchase 조회                                                                                                                                                         
List<PurchaseListProjection> purchases = queryFactory.select(...)
.where(purchase.userId.value.eq(userId)) // ← VIP 사용자시 대량 데이터

      // 2단계: Ticket 조회 (IN 절 사용)                                                                                                                                              
      List<TicketProjection> tickets = queryFactory.select(...)
          .where(ticket.purchase.purchaseId.value.in(purchaseIds)) // ← 대량 IN절                                                                                                     
}

// VIP 사용자의 경우:                                                                                                                                                               
// 1단계에서 200개 Purchase ID 반환                                                                                                                                                 
// 2단계에서 IN (id1, id2, ..., id200) 처리 → 매우 비효율적

  ---
⚠️ 3. 이벤트별 구매 내역 조회 - GET /api/v1/purchases/event/{eventId}

위험도: 🟡 높음

바이럴 이벤트 급증 패턴

-- BTS 콘서트 같은 인기 이벤트                                                                                                                                                      
SELECT p.*, t.* FROM purchases p JOIN tickets t ON ...
WHERE p.event_id = 'bts-seoul-2024'                                                                                                                                                 
AND p.payment_status = 'DONE'

바이럴 이벤트 특성:
일반 이벤트: 평균 500건 구매
인기 이벤트: 50,000건 구매 (100배 차이!)

옵티마이저 예상: "평균적으로 500건 정도"
실제 BTS 콘서트: 50,000건 → 서버 다운 위험

  ---
🟡 중간 위험도 API 분석

4. 매니저별 이벤트 조회 - GET /api/v1/events/manager/me

위험도: 🟡 중간

대형 기획사 vs 개인 매니저 편향

WHERE e.manager_id = 'sm-entertainment'                                                                                                                                             
-- SM Entertainment: 1,000개 이벤트                                                                                                                                                 
-- 개인 매니저: 평균 5개 이벤트

-- 옵티마이저가 평균(50개)으로 계산하면 대형사 쿼리시 성능 저하

  ---
🟢 낮은 위험도 API

5-7. 단순 조회 API들

- 좌석 레이아웃 조회: 단일 이벤트 기준, 안정적
- 사용자 정보 조회: 단건 조회, 위험도 낮음
- 카테고리 목록: 마스터 데이터, 변화량 적음

  ---
🔧 최적화 개선 방안

● 🎯 1. 이벤트 목록 조회 최적화

A) 동적 힌트 시스템 구현

@Service                                                                                                                                                                            
public class EventQueryOptimizer {

      private static final Set<Integer> PEAK_SEASON_MONTHS = Set.of(11, 12, 1, 5, 6, 7);
      private static final Set<String> HIGH_DEMAND_LOCATIONS = Set.of("서울", "부산", "대구");
      private static final Set<Long> POPULAR_CATEGORIES = Set.of(1L, 2L, 3L); // 콘서트, 뮤지컬, 스포츠                                                                               

      public Page<EventListProjection> findOptimizedEventList(                                                                                                                        
              String keyword, EventListFilter filter, Pageable pageable) {

          int riskScore = calculateQueryComplexity(filter);

          if (riskScore >= 7) { // 고위험 쿼리                                                                                                                                        
              return eventViewRepository.findEventListWithHashJoin(keyword, filter, pageable);
          } else {
              return eventViewRepository.findEventList(keyword, filter, pageable);
          }
      }

      private int calculateQueryComplexity(EventListFilter filter) {
          int complexity = 0;
          LocalDate now = LocalDate.now();

          // 성수기 가중치 (11-12월, 5-7월)                                                                                                                                           
          if (filter.getStartDate() != null &&
              PEAK_SEASON_MONTHS.contains(filter.getStartDate().getMonthValue())) {
              complexity += 3;
          }

          // 인기 지역 가중치                                                                                                                                                         
          if (filter.getLocationList() != null &&
              filter.getLocationList().stream().anyMatch(HIGH_DEMAND_LOCATIONS::contains)) {
              complexity += 2;
          }

          // 인기 카테고리 가중치                                                                                                                                                     
          if (filter.getCategoryId() != null && POPULAR_CATEGORIES.contains(filter.getCategoryId())) {
              complexity += 2;
          }

          // 키워드 검색 가중치                                                                                                                                                       
          if (keyword != null && keyword.length() > 0) {
              complexity += 1;
          }

          return complexity;
      }
}

B) 힌트 기반 Repository 확장

@Repository
public class EventViewRepositoryImpl implements EventViewRepository {

      // 기존 메서드 유지
      @Override
      public Page<EventListProjection> findEventList(String keyword, EventListFilter filter, Pageable pageable) {
          // 기존 구현
      }

      // Hash Join 강제 버전 추가
      public Page<EventListProjection> findEventListWithHashJoin(
              String keyword, EventListFilter filter, Pageable pageable) {

          // Native Query with USE_HASH hint
          String sql = """
              SELECT /*+ USE_HASH(e,s) */
                  e.event_id, e.title, e.thumbnail_url, e.event_start, e.event_end,
                  e.booking_start, e.booking_end, e.min_price, e.max_price,
                  e.view_count, e.status, e.category_id, s.location_name
              FROM events e
              JOIN seat_layouts s ON e.seat_layout_id = s.id
              WHERE e.deleted = false
              """ + buildDynamicWhereClause(keyword, filter) + """
              ORDER BY e.created_at DESC
              LIMIT ? OFFSET ?
              """;

          // JdbcTemplate 또는 EntityManager로 실행
          return executeWithHint(sql, keyword, filter, pageable);
      }
}

🎯 2. 구매 내역 조회 최적화

A) VIP 사용자 감지 및 최적화

@Service                                                                                                                                                                            
public class PurchaseQueryOptimizer {

      private final RedisTemplate<String, String> redisTemplate;

      public Page<PurchaseListProjection> findOptimizedUserPurchaseList(                                                                                                              
              String userId, List<PaymentStatus> statuses, Pageable pageable) {

          // Redis에서 사용자별 구매 통계 확인                                                                                                                                        
          String userStatsKey = "user:purchase:stats:" + userId;
          String cachedStats = redisTemplate.opsForValue().get(userStatsKey);

          boolean isVipUser = false;
          if (cachedStats != null) {
              UserPurchaseStats stats = parseStats(cachedStats);
              isVipUser = stats.getTotalPurchases() > 50 || stats.getTotalTickets() > 100;
          }

          if (isVipUser) {
              // VIP 사용자: 단일 쿼리로 JOIN 처리                                                                                                                                    
              return purchaseViewRepository.findUserPurchaseListWithSingleQuery(userId, statuses, pageable);
          } else {
              // 일반 사용자: 기존 2단계 쿼리                                                                                                                                         
              return purchaseViewRepository.findUserPurchaseList(userId, statuses, pageable);
          }
      }
}

B) VIP용 단일 쿼리 버전

public Page<PurchaseListProjection> findUserPurchaseListWithSingleQuery(
String userId, List<PaymentStatus> statuses, Pageable pageable) {

      // 한 번의 쿼리로 모든 데이터 조회 (Hash Join 힌트 포함)
      String sql = """
          SELECT /*+ USE_HASH(p,t) */
              p.purchase_id, p.order_id, p.order_name, p.event_id,
              p.amount, p.payment_method, p.payment_status, p.created_at, p.user_id,
              t.ticket_id, t.location, t.seat_id
          FROM purchases p
          LEFT JOIN tickets t ON p.purchase_id = t.purchase_id
          WHERE p.user_id = ? AND p.payment_status IN (?)
          ORDER BY p.created_at DESC
          LIMIT ? OFFSET ?
          """;

      // 결과를 PurchaseListProjection으로 그룹핑
      return executeAndGroup(sql, userId, statuses, pageable);
}

🎯 3. 실시간 통계 기반 최적화

A) 쿼리 성능 모니터링

@Component                                                                                                                                                                          
public class QueryPerformanceMonitor {

      private final MeterRegistry meterRegistry;
      private final Map<String, QueryStats> queryStatsMap = new ConcurrentHashMap<>();

      public <T> T executeWithMonitoring(String queryName, Supplier<T> queryExecutor) {
          Timer.Sample sample = Timer.start(meterRegistry);

          try {
              T result = queryExecutor.get();
              sample.stop(Timer.builder("query.execution.time")
                  .tag("query", queryName)
                  .tag("status", "success")
                  .register(meterRegistry));

              updateQueryStats(queryName, true);
              return result;

          } catch (Exception e) {
              sample.stop(Timer.builder("query.execution.time")
                  .tag("query", queryName)
                  .tag("status", "error")
                  .register(meterRegistry));

              updateQueryStats(queryName, false);
              throw e;
          }
      }

      private void updateQueryStats(String queryName, boolean success) {
          queryStatsMap.compute(queryName, (k, v) -> {
              if (v == null) v = new QueryStats();
              if (success) {
                  v.incrementSuccess();
              } else {
                  v.incrementFailure();
              }
              return v;
          });
      }

      // 성능이 저하되는 쿼리 자동 감지                                                                                                                                               
      @Scheduled(fixedRate = 60000) // 1분마다                                                                                                                                        
      public void detectSlowQueries() {
          queryStatsMap.entrySet().stream()
              .filter(entry -> entry.getValue().getAverageTime() > 5000) // 5초 이상                                                                                                  
              .forEach(entry -> {
                  log.warn("Slow query detected: {} - avg: {}ms",
                      entry.getKey(), entry.getValue().getAverageTime());

                  // 알람 또는 자동 힌트 적용 로직                                                                                                                                    
                  enableHashJoinHint(entry.getKey());
              });
      }
}

● 🎯 4. 데이터 편향 대응 전략

A) 사용자 세그멘테이션 기반 최적화

@Component                                                                                                                                                                          
public class UserSegmentOptimizer {

      enum UserSegment {
          LIGHT_USER(0, 10),      // 구매 0-10건                                                                                                                                      
          NORMAL_USER(11, 50),    // 구매 11-50건                                                                                                                                     
          HEAVY_USER(51, 200),    // 구매 51-200건                                                                                                                                    
          VIP_USER(201, Integer.MAX_VALUE); // 구매 200건+                                                                                                                            

          private final int minPurchases;
          private final int maxPurchases;
      }

      public UserSegment determineUserSegment(String userId) {
          // Redis 캐시에서 사용자 구매 통계 조회                                                                                                                                     
          Long purchaseCount = getUserPurchaseCount(userId);

          return Arrays.stream(UserSegment.values())
              .filter(segment -> purchaseCount >= segment.minPurchases &&
                               purchaseCount <= segment.maxPurchases)
              .findFirst()
              .orElse(UserSegment.NORMAL_USER);
      }

      public QueryStrategy getOptimalQueryStrategy(UserSegment segment) {
          return switch (segment) {
              case LIGHT_USER, NORMAL_USER -> QueryStrategy.NL_JOIN;
              case HEAVY_USER -> QueryStrategy.HASH_JOIN;
              case VIP_USER -> QueryStrategy.SINGLE_QUERY_HASH_JOIN;
          };
      }
}

B) 지역별 편향 대응

@Component                                                                                                                                                                          
public class LocationBasedOptimizer {

      // 실제 티켓팅 업계 데이터 기반                                                                                                                                                 
      private static final Map<String, Integer> LOCATION_EVENT_DENSITY = Map.of(
          "서울", 35000,      // 전체 이벤트의 70%                                                                                                                                    
          "경기", 5000,       // 10%                                                                                                                                                  
          "부산", 3000,       // 6%                                                                                                                                                   
          "대구", 2000,       // 4%                                                                                                                                                   
          "기타", 5000        // 10%                                                                                                                                                  
      );

      public boolean shouldUseHashJoin(EventListFilter filter) {
          if (filter.getLocationList() == null) return false;

          int totalExpectedEvents = filter.getLocationList().stream()
              .mapToInt(location -> LOCATION_EVENT_DENSITY.getOrDefault(location, 100))
              .sum();

          // 예상 결과가 5000개 이상이면 Hash Join 권장                                                                                                                               
          return totalExpectedEvents > 5000;
      }

      // 시간대별 패턴 분석                                                                                                                                                           
      public boolean isPeakSeason(LocalDateTime startDate, LocalDateTime endDate) {
          if (startDate == null || endDate == null) return false;

          // 연말시즌 (11-12월), 여름시즌 (6-8월) 체크                                                                                                                                
          int startMonth = startDate.getMonthValue();
          int endMonth = endDate.getMonthValue();

          Set<Integer> peakMonths = Set.of(6, 7, 8, 11, 12);
          return peakMonths.contains(startMonth) || peakMonths.contains(endMonth);
      }
}

🎯 5. 실시간 적응형 최적화 시스템

A) Circuit Breaker 패턴 적용

@Component                                                                                                                                                                          
public class QueryCircuitBreaker {

      private final Map<String, CircuitBreakerState> circuitStates = new ConcurrentHashMap<>();

      public <T> T executeWithCircuitBreaker(String queryName,                                                                                                                        
              Supplier<T> primaryQuery, Supplier<T> fallbackQuery) {

          CircuitBreakerState state = circuitStates.computeIfAbsent(
              queryName, k -> new CircuitBreakerState());

          if (state.isOpen()) {
              // Circuit Open: Fallback 쿼리 사용 (힌트 적용)                                                                                                                         
              log.warn("Circuit breaker OPEN for {}, using fallback query", queryName);
              return fallbackQuery.get();
          }

          try {
              T result = primaryQuery.get();
              state.recordSuccess();
              return result;

          } catch (Exception e) {
              state.recordFailure();

              if (state.shouldOpen()) {
                  log.error("Circuit breaker OPENING for {} due to failures", queryName);
                  return fallbackQuery.get();
              }
              throw e;
          }
      }

      static class CircuitBreakerState {
          private final AtomicInteger failureCount = new AtomicInteger(0);
          private final AtomicLong lastFailureTime = new AtomicLong(0);
          private final int threshold = 5; // 5번 실패시 Open                                                                                                                         
          private final long timeout = 60000; // 1분 후 Half-Open                                                                                                                     

          boolean isOpen() {
              if (failureCount.get() >= threshold) {
                  return System.currentTimeMillis() - lastFailureTime.get() < timeout;
              }
              return false;
          }

          void recordSuccess() {
              failureCount.set(0);
          }

          void recordFailure() {
              failureCount.incrementAndGet();
              lastFailureTime.set(System.currentTimeMillis());
          }

          boolean shouldOpen() {
              return failureCount.get() >= threshold;
          }
      }
}

B) 적응형 쿼리 실행기

@Service                                                                                                                                                                            
public class AdaptiveQueryExecutor {

      private final QueryCircuitBreaker circuitBreaker;
      private final EventViewRepository eventRepository;
      private final LocationBasedOptimizer locationOptimizer;

      public Page<EventListProjection> executeAdaptiveEventQuery(                                                                                                                     
              String keyword, EventListFilter filter, Pageable pageable) {

          String queryKey = generateQueryKey(keyword, filter);

          // Primary: 옵티마이저 믿고 일반 쿼리                                                                                                                                       
          Supplier<Page<EventListProjection>> primaryQuery = () ->
              eventRepository.findEventList(keyword, filter, pageable);

          // Fallback: 힌트 적용한 강화 쿼리                                                                                                                                          
          Supplier<Page<EventListProjection>> fallbackQuery = () ->
              eventRepository.findEventListWithHashJoin(keyword, filter, pageable);

          return circuitBreaker.executeWithCircuitBreaker(
              queryKey, primaryQuery, fallbackQuery);
      }

      private String generateQueryKey(String keyword, EventListFilter filter) {
          return String.format("event_query_%s_%s_%s_%s",
              keyword != null ? "with_keyword" : "no_keyword",
              filter.getCategoryId() != null ? "with_category" : "no_category",
              filter.getLocationList() != null ? "with_location" : "no_location",
              locationOptimizer.isPeakSeason(filter.getStartDate(), filter.getEndDate())
                  ? "peak_season" : "normal_season"                                                                                                                                   
          );
      }
}

  ---
📊 종합 위험도 평가 및 우선순위

🔴 긴급 대응 필요 (High Priority)

1. 이벤트 목록 조회 API
   - 위험도: ★★★★★ (5/5)
   - 영향도: 메인 화면, 검색 기능
   - 예상 성능 차이: 15배 (NL vs Hash Join)
   - 대응책: 즉시 적응형 최적화 시스템 도입
2. VIP 사용자 구매 내역 조회
   - 위험도: ★★★★☆ (4/5)
   - 영향도: 고객 만족도 직결
   - 예상 성능 차이: 10배
   - 대응책: 사용자 세그멘테이션 기반 쿼리 분기

🟡 지속 모니터링 필요 (Medium Priority)

3. 이벤트별 구매 내역 조회 (매니저용)
   - 위험도: ★★★☆☆ (3/5)
   - 영향도: 매니저 업무 효율성
   - 대응책: 인기 이벤트 자동 감지 시스템
4. 매니저별 이벤트 조회
   - 위험도: ★★☆☆☆ (2/5)
   - 영향도: 특정 대형 매니저 계정
   - 대응책: 매니저별 이벤트 수 통계 기반 최적화

🟢 현재 안정적 (Low Priority)

5. 나머지 API들 - 단건 조회 및 마스터 데이터 조회
   - 위험도: ★☆☆☆☆ (1/5)
   - 대응책: 기본 모니터링만 유지

  ---

● 🎯 실행 계획 (Implementation Roadmap)

Phase 1: 즉시 적용 (1-2주)

// 1. 기본적인 동적 힌트 시스템                                                                                                                                                     
@Service                                                                                                                                                                            
public class QuickOptimizationService {

      public Page<EventListProjection> findEventsWithSmartOptimization(                                                                                                               
              String keyword, EventListFilter filter, Pageable pageable) {

          // 간단한 위험도 계산                                                                                                                                                       
          boolean isHighRisk = (filter.getLocationList() != null &&
                              filter.getLocationList().contains("서울")) ||
                             (filter.getCategoryId() != null &&
                              filter.getCategoryId() <= 3L) ||
                             (isPeakSeason());

          if (isHighRisk) {
              return eventViewRepository.findEventListWithHashJoin(keyword, filter, pageable);
          }
          return eventViewRepository.findEventList(keyword, filter, pageable);
      }
}

Phase 2: 고도화 (1개월)

- 사용자 세그멘테이션 시스템 구축
- Circuit Breaker 패턴 적용
- 실시간 성능 모니터링 대시보드

Phase 3: AI 기반 최적화 (3개월)

- 머신러닝 기반 쿼리 패턴 예측
- 자동 인덱스 추천 시스템
- 예측적 캐싱 전략

  ---
🔍 결론: Ticketon DDD의 옵티마이저 실패 위험도

현재 Ticketon DDD 시스템은 **"급성장 스타트업의 전형적인 옵티마이저 실패 함정"**에 빠질 가능성이 매우 높습니다.

핵심 위험 요소:

1. 데이터 폭발적 증가 - 이벤트/구매 데이터의 기하급수적 성장
2. 극심한 지역 편향 - 서울 집중도 70% 이상
3. 계절적 트래픽 급증 - 연말시즌 6배 증가
4. VIP 사용자 편향 - 상위 1% 사용자가 전체 구매의 40% 차지

예상 성능 영향:

- 이벤트 조회 API: 정상 2초 → 최악 30분 (15배 차이)
- VIP 구매내역: 정상 1초 → 최악 10분 (10배 차이)

비즈니스 리스크:

- 연말시즌 서버 다운 가능성
- VIP 고객 이탈 위험
- 매출 기회 손실

따라서 제시한 적응형 최적화 시스템의 도입이 시급합니다! 🚨