# 인증 모듈 분리

## 1. 분리 이유
대기열 API는 로그인한 유저만 사용 가능합니다. 그러나 대기열 서버를 기존 서버에서 분리했기 때문에, 대기열 서버 또한 로그인 및 인증 로직이 필요했습니다. 

임시방편으로 대기열 서버에도 메인 서버와 같은 로그인, 인가 코드를 복사해 추가하고, 컨트롤러를 연결해 해결했습니다. 이러한 구조는 추후 로그인 로직이 변경되었을 때, 동일 코드를 중복으로 수정해야 하므로, 유지보수에 큰 문제가 될 수 있다고 생각했습니다.

## 2. 해결 방법

### 1. DB 스키마 분리
로그인 코드를 모듈로 분리하고, 두 모듈(대기열과 메인)에서 이를 임포트해 사용하면, 동일 코드 중복을 막을 수 있습니다.

로그인 절차를 모듈로 분리하기 위해, Auth 모듈을 작성하고 로그인 로직을 추가했습니다. 이 과정에서 User 테이블에 변화가 생겼는데, User 테이블은 기존에 인증을 위한 정보 (username, password, 계정 잠김 여부 등)과 유저의 개인정보가 함꼐 포함되어 있었습니다.

인증 과정을 기존의 로직과 완벽하게 분리하기 위해서는, 스키마 수준에서의 변경 또한 필요하다고 생각했습니다. 이에 따라 SecurityUser 테이블을 추가해 유저 인증 관련 정보만 분리하게 되었습니다.


### 2. 모듈 패키지 정의
패키지 구조는 DDD에 기반해 ui - app - domain - infra 형식을 따르게 되었습니다. ui에는 controller, app에는 서비스, domain에는 엔티티, infra에는 jpa repository가 들어가게 됩니다.

#### 2.1 DDD 기반 엔티티 작성
Auth 모듈의 루트 어그리거트 엔티티는 SecurityUser가 됩니다.

DDD로 엔티티를 작성하면서 가장 중요시 한 부분은 '엔티티 생성 시점에 객체가 완성되도록 하기'와 '도메인 로직을 멤버 메소드로 관리하기'입니다.
따라서 핵심 비즈니스 로직인 `rawPassword`와 `encodedPassword`를 비교하는 `match()` 메서드를 SecurityUser 클래스의 메소드로 추가했습니다.
또한, SecurityUser의 새로운 객체를 생성할 때, 생성자에 `validate()` 내부 메서드를 정의하고 호출해, 생성자의 파라미터를 검사하였습니다.

```java



```java
	public void match(String password, PasswordEncoder passwordEncoder) {
		if (!passwordEncoder.matches(password, this.password)){
			throw new AccessDeniedException("Password match failed");
		}
	}
```